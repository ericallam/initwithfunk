<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swizzling | initWithFunk:]]></title>
  <link href="http://initwithfunk.com/blog/categories/swizzling/atom.xml" rel="self"/>
  <link href="http://initwithfunk.com/"/>
  <updated>2014-02-18T10:51:31+00:00</updated>
  <id>http://initwithfunk.com/</id>
  <author>
    <name><![CDATA[Eric Allam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Do the Swizzle]]></title>
    <link href="http://initwithfunk.com/blog/2014/02/18/do-the-swizzle/"/>
    <updated>2014-02-18T08:00:00+00:00</updated>
    <id>http://initwithfunk.com/blog/2014/02/18/do-the-swizzle</id>
    <content type="html"><![CDATA[<p><a href="http://nshipster.com/method-swizzling/">Method swizzling</a> has recently hit the mainstream. It&rsquo;s a technique we use at <a href="http://www.codeschool.com/paths/ios">Code School</a> quite a bit. For example, if you look inside the downloaded projects for <a href="http://ios7.codeschool.com/levels/1">Core iOS 7</a>, you&rsquo;ll see plenty of swizzling going on and most of the time the technique described in mattt&rsquo;s <a href="http://nshipster.com/method-swizzling/">post</a> is sufficient. But every once in awhile you&rsquo;ll try to sizzle a method and for some strange reason it doesn&rsquo;t work. It&rsquo;s like the class is immune to your swizzling ways.</p>

<p>I ran into one of these immune classes when trying to swizzle the <code>downloadTaskWithURL:</code> method on <code>NSURLSession</code> using the traditional category-based technique. I wanted to make sure the <a href="http://www.codeschool.com/paths/ios">Code School</a> student called <code>downloadTaskWithURL:</code> with the correct parameters.</p>

<p>Here what the calling-code looked like:</p>

<p>```objc
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>NSURLSessionConfiguration *default = [NSURLSessionConfiguration defaultSessionConfiguration];
NSURLSession *session = [NSURLSession sessionWithConfiguration:default 
                                                      delegate:self 
                                                 delegateQueue:[NSOperationQueue mainQueue]];

NSURL *URL = [NSURL URLWithString:@"http://initwithfunk.com"];

NSURLSessionDownloadTask *task = [session downloadTaskWithURL:URL];
[task resume];

return YES;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)URLSession:(NSURLSession <em>)session task:(NSURLSessionTask </em>)task didCompleteWithError:(NSError <em>)error
{
  NSHTTPURLResponse </em>response = (NSHTTPURLResponse *)task.response;</p>

<p>  NSLog(@&ldquo;Task did complete with status: %d&rdquo;, response.statusCode);
}
```</p></li>
</ul>


<p>And the swizzling category (this isn&rsquo;t exactly how it worked but essentially it did the same thing):</p>

<p>```objc</p>

<h1>import &ldquo;NSURLSession+Swizzle.h&rdquo;</h1>

<h1>import &lt;objc/runtime.h></h1>

<p>@implementation NSURLSession (Swizzle)</p>

<ul>
<li><p>(void)load{
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
      Class class = self.class;</p>

<pre><code>  SEL originalSelector = @selector(downloadTaskWithURL:);
  SEL swizzledSelector = @selector(xxx_downloadTaskWithURL:);

  Method originalMethod = class_getInstanceMethod(class, originalSelector);
  Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);

  IMP swizzledImp = method_getImplementation(swizzledMethod);
  IMP originalImp = method_getImplementation(originalMethod);

  BOOL didAddMethod =
  class_addMethod(class,
                  originalSelector,
                  swizzledImp,
                  method_getTypeEncoding(swizzledMethod));

  if (didAddMethod) {
      class_replaceMethod(class,
                          swizzledSelector,
                          originalImp,
                          method_getTypeEncoding(originalMethod));
  } else {
      method_exchangeImplementations(originalMethod, swizzledMethod);
  }
</code></pre>

<p>  });
}</p></li>
<li><p>(NSURLSessionDownloadTask <em>)xxx_downloadTaskWithURL:(NSURL </em>)url
{
  NSLog(@&ldquo;%s&rdquo;, <strong>PRETTY_FUNCTION</strong>);</p>

<p>  return [self xxx_downloadTaskWithURL:url];
}</p></li>
</ul>


<p>@end
```</p>

<p>When this ran, the <code>xxx_</code> method would never get called. I stepped through the <code>+load</code> and everything seemed to be working just fine. But when I logged the pointers of the <code>class</code> I was swizzling in <code>+load</code> and the <code>class</code> of the <code>NSURLSession</code> instance I was using in the app delegate, I discovered that they were pointing to different locations in memory.</p>

<p>So I tried updating the <code>+load</code> method. Instead of using <code>self.class</code>, I would grab the class from an actual instance of <code>NSURLSession</code>, like so:</p>

<p><code>objc
Class class = [NSURLSession sharedSession].class;
</code></p>

<p>Unfortunately, that led to the <code>class_getInstanceMethod(class, swizzledSelector)</code> call returning nil since it was no longer looking in the class that included the <code>xxx_downloadTaskWithURL:</code> method. Replacing that code with <code>class_getInstanceMethod(self.class, swizzledSelector)</code> won&rsquo;t work either, leading to a <code>-[__NSCFURLSession xxx_downloadTaskWithURL:]: unrecognized selector</code> error when the implementation of the swizzle method tries to call back to the original method that doesn&rsquo;t exist.</p>

<h3>Category-less Swizzle</h3>

<p>It turns out there is a more direct way to swizzle methods without first defining the replacement method on the same class as the original method. <a href="https://twitter.com/mikeash">Mike Ash</a> details this technique in a fantastic swizzling <a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html">Friday Q&amp;A</a>:</p>

<p>```objc
// Create a function pointer for the original downloadTaskWithURL: to be stored in
static NSURLSessionDownloadTask * (<em>OriginalDownloadedTaskWithURL)(id, SEL, NSURL </em>);</p>

<p>// Define our custom implementation of downloadTaskWithURL:, calling OriginalDownloadedTaskWithURL
// to call the original method
static NSURLSessionDownloadTask * `(id self, SEL _cmd, NSURL *url){</p>

<pre><code>NSLog(@"%s", __PRETTY_FUNCTION__);

NSURLSessionDownloadTask *task = OriginalDownloadedTaskWithURL(self, _cmd, url);

return task;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)load
{
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{</p>

<pre><code>  // Replace the method on the same class that's used
  // In the calling code
  Class class = [NSURLSession sharedSession].class;

  SEL originalSelector = @selector(downloadTaskWithURL:);

  // The replacemethod method implementation
  IMP replacement = (IMP)CustomDownloadTaskWithURL;

  // This will eventually hold the original downloadTaskWithURL: method
  IMP *store = (IMP *)&amp;OriginalDownloadedTaskWithURL;

  IMP originalImp = NULL;
  Method method = class_getInstanceMethod(class, originalSelector);
  if (method) {
      const char *type = method_getTypeEncoding(method);
      // Replace the original method with the XXXDownloadTaskWithURL IMP function
      originalImp = class_replaceMethod(class, originalSelector, replacement, type);
      if (!originalImp) {
          originalImp = method_getImplementation(method);
      }
  }

  // Put the original method IMP into the store pointer
  if (originalImp &amp;&amp; store) { *store = originalImp; }
</code></pre>

<p>  });
}
```</p></li>
</ul>


<p>Since all objective-c methods eventually just become a C function with the first two arguments of <code>id self</code> and <code>SEL _cmd</code>, we can just go ahead and define the replacement method as a static function called <code>XXXDownloadTaskWithURL</code> that accepts self, _cmd, and an <code>NSURL *</code> as the &ldquo;first&rdquo; argument.</p>

<p>We also create a place to store the original method, a pointer to an IMP pointer called <code>OriginalDownloadedTaskWithURL</code> which will allow our replacement method to call back out to the original.  Of course the <a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html">original</a> description of this approach is a better so definitely check it out.</p>

<h3>Why doesn&rsquo;t category-based swizzling work for NSURLSession?</h3>

<p>I&rsquo;m not exactly sure what makes <code>NSURLSession</code> immune to the category based swizzle. I think it has something to do with it possibly being a class-cluster, or maybe it has to do with it being a toll-free bridged class to <code>__NSCFURLSession</code>. I&rsquo;m not sure.</p>

<p>If you know the answer, I&rsquo;d love to hear about it. Message me on twitter <a href="http://twitter.com/eallam">@eallam</a>.</p>
]]></content>
  </entry>
  
</feed>
